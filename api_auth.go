/*
Eon API

The Eon.io REST API

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package eon

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// AuthAPIService AuthAPI service
type AuthAPIService service

type ApiGetAccessTokenRequest struct {
	ctx context.Context
	ApiService *AuthAPIService
	apiCredentials *ApiCredentials
}

func (r ApiGetAccessTokenRequest) ApiCredentials(apiCredentials ApiCredentials) ApiGetAccessTokenRequest {
	r.apiCredentials = &apiCredentials
	return r
}

func (r ApiGetAccessTokenRequest) Execute() (*TokenResponse, *http.Response, error) {
	return r.ApiService.GetAccessTokenExecute(r)
}

/*
GetAccessToken Get Access Token

Description: Retrieves an access token, which you then pass in the `Authorization` header when calling API methods.

The client ID and secret you provide when calling this method must be from a set of API credentials from your Eon account.
To learn more about creating API credentials and completing the authentication flow, see [Authentication](/api/using-the-api/authentication).

The returned access token has the permissions included in the role you assigned to the API credentials.
Always make sure the API credentials have the permissions needed for the API methods you want to use it for.

The access token is valid for 12 hours.
After that, you must call this method again to get a new token.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccessTokenRequest
*/
func (a *AuthAPIService) GetAccessToken(ctx context.Context) ApiGetAccessTokenRequest {
	return ApiGetAccessTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TokenResponse
func (a *AuthAPIService) GetAccessTokenExecute(r ApiGetAccessTokenRequest) (*TokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthAPIService.GetAccessToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiCredentials == nil {
		return localVarReturnValue, nil, reportError("apiCredentials is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiCredentials
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccessTokenOAuth2Request struct {
	ctx context.Context
	ApiService *AuthAPIService
	clientId *string
	clientSecret *string
	grantType *string
	refreshToken *string
}

// Your integration&#39;s client ID.
func (r ApiGetAccessTokenOAuth2Request) ClientId(clientId string) ApiGetAccessTokenOAuth2Request {
	r.clientId = &clientId
	return r
}

// Your integration&#39;s client secret.
func (r ApiGetAccessTokenOAuth2Request) ClientSecret(clientSecret string) ApiGetAccessTokenOAuth2Request {
	r.clientSecret = &clientSecret
	return r
}

// The OAuth2 grant you are using.
func (r ApiGetAccessTokenOAuth2Request) GrantType(grantType string) ApiGetAccessTokenOAuth2Request {
	r.grantType = &grantType
	return r
}

// Refresh token. Required if &#x60;grant_type&#x60; is &#x60;refresh_token&#x60;. 
func (r ApiGetAccessTokenOAuth2Request) RefreshToken(refreshToken string) ApiGetAccessTokenOAuth2Request {
	r.refreshToken = &refreshToken
	return r
}

func (r ApiGetAccessTokenOAuth2Request) Execute() (*Oauth2TokenResponse, *http.Response, error) {
	return r.ApiService.GetAccessTokenOAuth2Execute(r)
}

/*
GetAccessTokenOAuth2 Get Access Token (OAuth2)

Description: OAuth2-compliant token endpoint that accepts form-encoded credentials using standard `client_id` and `client_secret` field names.

This endpoint is specifically designed for OAuth2 clients like Grafana that send credentials as form-encoded data.
For JSON-based API calls, use the standard `/v1/token` endpoint instead.

The client ID and secret you provide when calling this method must be from a set of API credentials from your Eon account.
To learn more about creating API credentials and completing the authentication flow, see [Authentication](/api/using-the-api/authentication).

The returned access token has the permissions included in the role you assigned to the API credentials.
Always make sure the API credentials have the permissions needed for the API methods you want to use it for.

The access token is valid for 12 hours.
After that, you must call this method again to get a new token.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccessTokenOAuth2Request
*/
func (a *AuthAPIService) GetAccessTokenOAuth2(ctx context.Context) ApiGetAccessTokenOAuth2Request {
	return ApiGetAccessTokenOAuth2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Oauth2TokenResponse
func (a *AuthAPIService) GetAccessTokenOAuth2Execute(r ApiGetAccessTokenOAuth2Request) (*Oauth2TokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Oauth2TokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthAPIService.GetAccessTokenOAuth2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/oauth2/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientId == nil {
		return localVarReturnValue, nil, reportError("clientId is required and must be specified")
	}
	if r.clientSecret == nil {
		return localVarReturnValue, nil, reportError("clientSecret is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "client_id", r.clientId, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "client_secret", r.clientSecret, "")
	if r.grantType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "grant_type", r.grantType, "")
	}
	if r.refreshToken != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "refresh_token", r.refreshToken, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
