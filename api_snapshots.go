/*
Eon API

The Eon.io REST API

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package eon

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SnapshotsAPIService SnapshotsAPI service
type SnapshotsAPIService service

type ApiGetSnapshotRequest struct {
	ctx context.Context
	ApiService *SnapshotsAPIService
	id string
	projectId string
}

func (r ApiGetSnapshotRequest) Execute() (*GetSnapshotResponse, *http.Response, error) {
	return r.ApiService.GetSnapshotExecute(r)
}

/*
GetSnapshot Get Snapshot

Description: Retrieves an Eon snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the Eon snapshot to retrieve.
 @param projectId ID of the project the snapshot is in. You can get your project ID from the [API Credentials](/global-settings/api-credentials) page in your global settings. 
 @return ApiGetSnapshotRequest
*/
func (a *SnapshotsAPIService) GetSnapshot(ctx context.Context, id string, projectId string) ApiGetSnapshotRequest {
	return ApiGetSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return GetSnapshotResponse
func (a *SnapshotsAPIService) GetSnapshotExecute(r ApiGetSnapshotRequest) (*GetSnapshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSnapshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SnapshotsAPIService.GetSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/snapshots/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListResourceSnapshotsRequest struct {
	ctx context.Context
	ApiService *SnapshotsAPIService
	id string
	projectId string
	pageToken *string
	pageSize *int32
	listInventorySnapshotsRequest *ListInventorySnapshotsRequest
}

// Cursor that points to the first record of the next page of results. Get this value from the previous response. To preserve the results in the same order, use the same sorting and filters in the first request as all subsequent requests. 
func (r ApiListResourceSnapshotsRequest) PageToken(pageToken string) ApiListResourceSnapshotsRequest {
	r.pageToken = &pageToken
	return r
}

// Maximum number of items to return in the response.
func (r ApiListResourceSnapshotsRequest) PageSize(pageSize int32) ApiListResourceSnapshotsRequest {
	r.pageSize = &pageSize
	return r
}

// Filter options.
func (r ApiListResourceSnapshotsRequest) ListInventorySnapshotsRequest(listInventorySnapshotsRequest ListInventorySnapshotsRequest) ApiListResourceSnapshotsRequest {
	r.listInventorySnapshotsRequest = &listInventorySnapshotsRequest
	return r
}

func (r ApiListResourceSnapshotsRequest) Execute() (*ListInventorySnapshotsResponse, *http.Response, error) {
	return r.ApiService.ListResourceSnapshotsExecute(r)
}

/*
ListResourceSnapshots List Resource Snapshots

Description: Retrieves a list of Eon snapshots for the given resource.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Eon-assigned ID of the resource whose Eon snapshots you want to retrieve.
 @param projectId ID of the project the resource is in. You can get your project ID from the [API Credentials](/global-settings/api-credentials) page in your global settings. 
 @return ApiListResourceSnapshotsRequest
*/
func (a *SnapshotsAPIService) ListResourceSnapshots(ctx context.Context, id string, projectId string) ApiListResourceSnapshotsRequest {
	return ApiListResourceSnapshotsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ListInventorySnapshotsResponse
func (a *SnapshotsAPIService) ListResourceSnapshotsExecute(r ApiListResourceSnapshotsRequest) (*ListInventorySnapshotsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListInventorySnapshotsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SnapshotsAPIService.ListResourceSnapshots")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/resources/{id}/snapshots"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageToken", r.pageToken, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.listInventorySnapshotsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestoreAzureDiskRequest struct {
	ctx context.Context
	ApiService *SnapshotsAPIService
	projectId string
	id string
	snapshotId string
	restoreAzureDiskRequest *RestoreAzureDiskRequest
}

func (r ApiRestoreAzureDiskRequest) RestoreAzureDiskRequest(restoreAzureDiskRequest RestoreAzureDiskRequest) ApiRestoreAzureDiskRequest {
	r.restoreAzureDiskRequest = &restoreAzureDiskRequest
	return r
}

func (r ApiRestoreAzureDiskRequest) Execute() (*RestoreJobInitiationResponse, *http.Response, error) {
	return r.ApiService.RestoreAzureDiskExecute(r)
}

/*
RestoreAzureDisk Restore Azure Disk

Description: Restores an Azure disk from an Eon snapshot.

When restoring a disk, you'll specify the configurations of the disk you want to restore.
You can retrieve the configurations from the snapshot by calling [Get Snapshot](/api/reference/get-snapshot) or [List Resource Snapshots](/api/reference/list-resource-snapshots).

This operation is asynchronous.
It triggers a restore job and returns a job ID, which can be used to track the progress of the restore job.
You can follow the progress of the restore job by calling [Get Restore Job](/api/reference/get-restore-job) with the job ID.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId ID of the project the snapshot is in. You can get your project ID from the [API Credentials](/global-settings/api-credentials) page in your global settings. 
 @param id Eon-assigned resource ID.
 @param snapshotId ID of the Eon [snapshot](./list-resource-snapshots) to restore.
 @return ApiRestoreAzureDiskRequest
*/
func (a *SnapshotsAPIService) RestoreAzureDisk(ctx context.Context, projectId string, id string, snapshotId string) ApiRestoreAzureDiskRequest {
	return ApiRestoreAzureDiskRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		id: id,
		snapshotId: snapshotId,
	}
}

// Execute executes the request
//  @return RestoreJobInitiationResponse
func (a *SnapshotsAPIService) RestoreAzureDiskExecute(r ApiRestoreAzureDiskRequest) (*RestoreJobInitiationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestoreJobInitiationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SnapshotsAPIService.RestoreAzureDisk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/resources/{id}/snapshots/{snapshotId}/restore-azure-disk"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", url.PathEscape(parameterValueToString(r.snapshotId, "snapshotId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restoreAzureDiskRequest == nil {
		return localVarReturnValue, nil, reportError("restoreAzureDiskRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restoreAzureDiskRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestoreAzureSqlDatabaseRequest struct {
	ctx context.Context
	ApiService *SnapshotsAPIService
	projectId string
	id string
	snapshotId string
	restoreAzureSqlDatabaseRequest *RestoreAzureSqlDatabaseRequest
}

// The request body for restoring the instance
func (r ApiRestoreAzureSqlDatabaseRequest) RestoreAzureSqlDatabaseRequest(restoreAzureSqlDatabaseRequest RestoreAzureSqlDatabaseRequest) ApiRestoreAzureSqlDatabaseRequest {
	r.restoreAzureSqlDatabaseRequest = &restoreAzureSqlDatabaseRequest
	return r
}

func (r ApiRestoreAzureSqlDatabaseRequest) Execute() (*RestoreJobInitiationResponse, *http.Response, error) {
	return r.ApiService.RestoreAzureSqlDatabaseExecute(r)
}

/*
RestoreAzureSqlDatabase Restore Azure SQL Database

Description: Restores an Azure SQL Database from an Eon snapshot.

This operation is asynchronous.
It triggers a restore job and returns a job ID, which can be used to track the progress of the restore job.
You can follow the progress of the restore job by calling [Get Restore Job](/api/reference/get-restore-job) with the job ID.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId ID of the project the snapshot is in. You can get your project ID from the [API Credentials](/global-settings/api-credentials) page in your global settings. 
 @param id Eon-assigned resource ID.
 @param snapshotId ID of the Eon [snapshot](./list-resource-snapshots) to restore.
 @return ApiRestoreAzureSqlDatabaseRequest
*/
func (a *SnapshotsAPIService) RestoreAzureSqlDatabase(ctx context.Context, projectId string, id string, snapshotId string) ApiRestoreAzureSqlDatabaseRequest {
	return ApiRestoreAzureSqlDatabaseRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		id: id,
		snapshotId: snapshotId,
	}
}

// Execute executes the request
//  @return RestoreJobInitiationResponse
func (a *SnapshotsAPIService) RestoreAzureSqlDatabaseExecute(r ApiRestoreAzureSqlDatabaseRequest) (*RestoreJobInitiationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestoreJobInitiationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SnapshotsAPIService.RestoreAzureSqlDatabase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/resources/{id}/snapshots/{snapshotId}/restore-azure-sql-database"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", url.PathEscape(parameterValueToString(r.snapshotId, "snapshotId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restoreAzureSqlDatabaseRequest == nil {
		return localVarReturnValue, nil, reportError("restoreAzureSqlDatabaseRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restoreAzureSqlDatabaseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestoreAzureVmInstanceRequest struct {
	ctx context.Context
	ApiService *SnapshotsAPIService
	projectId string
	id string
	snapshotId string
	restoreAzureVmInstanceRequest *RestoreAzureVmInstanceRequest
}

func (r ApiRestoreAzureVmInstanceRequest) RestoreAzureVmInstanceRequest(restoreAzureVmInstanceRequest RestoreAzureVmInstanceRequest) ApiRestoreAzureVmInstanceRequest {
	r.restoreAzureVmInstanceRequest = &restoreAzureVmInstanceRequest
	return r
}

func (r ApiRestoreAzureVmInstanceRequest) Execute() (*RestoreJobInitiationResponse, *http.Response, error) {
	return r.ApiService.RestoreAzureVmInstanceExecute(r)
}

/*
RestoreAzureVmInstance Restore Azure VM Instance

Description: Restores an Azure VM instance from an Eon snapshot.

This operation is asynchronous.
It triggers a restore job and returns a job ID, which can be used to track the progress of the restore job.
You can follow the progress of the restore job by calling [Get Restore Job](/api/reference/get-restore-job) with the job ID.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId ID of the project the snapshot is in. You can get your project ID from the [API Credentials](/global-settings/api-credentials) page in your global settings. 
 @param id Eon-assigned resource ID.
 @param snapshotId ID of the Eon [snapshot](./list-resource-snapshots) to restore.
 @return ApiRestoreAzureVmInstanceRequest
*/
func (a *SnapshotsAPIService) RestoreAzureVmInstance(ctx context.Context, projectId string, id string, snapshotId string) ApiRestoreAzureVmInstanceRequest {
	return ApiRestoreAzureVmInstanceRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		id: id,
		snapshotId: snapshotId,
	}
}

// Execute executes the request
//  @return RestoreJobInitiationResponse
func (a *SnapshotsAPIService) RestoreAzureVmInstanceExecute(r ApiRestoreAzureVmInstanceRequest) (*RestoreJobInitiationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestoreJobInitiationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SnapshotsAPIService.RestoreAzureVmInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/resources/{id}/snapshots/{snapshotId}/restore-azure-vm-instance"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", url.PathEscape(parameterValueToString(r.snapshotId, "snapshotId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restoreAzureVmInstanceRequest == nil {
		return localVarReturnValue, nil, reportError("restoreAzureVmInstanceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restoreAzureVmInstanceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestoreBucketRequest struct {
	ctx context.Context
	ApiService *SnapshotsAPIService
	projectId string
	id string
	snapshotId string
	restoreBucketRequest *RestoreBucketRequest
}

func (r ApiRestoreBucketRequest) RestoreBucketRequest(restoreBucketRequest RestoreBucketRequest) ApiRestoreBucketRequest {
	r.restoreBucketRequest = &restoreBucketRequest
	return r
}

func (r ApiRestoreBucketRequest) Execute() (*RestoreJobInitiationResponse, *http.Response, error) {
	return r.ApiService.RestoreBucketExecute(r)
}

/*
RestoreBucket Restore Bucket

Description: Restores a bucket from an Eon snapshot.

This operation is asynchronous.
It triggers a restore job and returns a job ID, which can be used to track the progress of the restore job.
You can follow the progress of the restore job by calling [Get Restore Job](/api/reference/get-restore-job) with the job ID.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId ID of the project the snapshot is in. You can get your project ID from the [API Credentials](/global-settings/api-credentials) page in your global settings. 
 @param id Eon-assigned resource ID.
 @param snapshotId ID of the Eon [snapshot](./list-resource-snapshots) to restore.
 @return ApiRestoreBucketRequest
*/
func (a *SnapshotsAPIService) RestoreBucket(ctx context.Context, projectId string, id string, snapshotId string) ApiRestoreBucketRequest {
	return ApiRestoreBucketRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		id: id,
		snapshotId: snapshotId,
	}
}

// Execute executes the request
//  @return RestoreJobInitiationResponse
func (a *SnapshotsAPIService) RestoreBucketExecute(r ApiRestoreBucketRequest) (*RestoreJobInitiationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestoreJobInitiationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SnapshotsAPIService.RestoreBucket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/resources/{id}/snapshots/{snapshotId}/restore-bucket"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", url.PathEscape(parameterValueToString(r.snapshotId, "snapshotId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restoreBucketRequest == nil {
		return localVarReturnValue, nil, reportError("restoreBucketRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restoreBucketRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestoreDatabaseRequest struct {
	ctx context.Context
	ApiService *SnapshotsAPIService
	projectId string
	id string
	snapshotId string
	restoreDbToRdsInstanceRequest *RestoreDbToRdsInstanceRequest
}

func (r ApiRestoreDatabaseRequest) RestoreDbToRdsInstanceRequest(restoreDbToRdsInstanceRequest RestoreDbToRdsInstanceRequest) ApiRestoreDatabaseRequest {
	r.restoreDbToRdsInstanceRequest = &restoreDbToRdsInstanceRequest
	return r
}

func (r ApiRestoreDatabaseRequest) Execute() (*RestoreJobInitiationResponse, *http.Response, error) {
	return r.ApiService.RestoreDatabaseExecute(r)
}

/*
RestoreDatabase Restore RDS Instance

Description: Restores an RDS instance from an Eon snapshot.

This operation is asynchronous.
It triggers a restore job and returns a job ID, which can be used to track the progress of the restore job.
You can follow the progress of the restore job by calling [Get Restore Job](/api/reference/get-restore-job) with the job ID.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId ID of the project the snapshot is in. You can get your project ID from the [API Credentials](/global-settings/api-credentials) page in your global settings. 
 @param id Eon-assigned resource ID.
 @param snapshotId ID of the Eon [snapshot](./list-resource-snapshots) to restore.
 @return ApiRestoreDatabaseRequest
*/
func (a *SnapshotsAPIService) RestoreDatabase(ctx context.Context, projectId string, id string, snapshotId string) ApiRestoreDatabaseRequest {
	return ApiRestoreDatabaseRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		id: id,
		snapshotId: snapshotId,
	}
}

// Execute executes the request
//  @return RestoreJobInitiationResponse
func (a *SnapshotsAPIService) RestoreDatabaseExecute(r ApiRestoreDatabaseRequest) (*RestoreJobInitiationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestoreJobInitiationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SnapshotsAPIService.RestoreDatabase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/resources/{id}/snapshots/{snapshotId}/restore-rds-instance"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", url.PathEscape(parameterValueToString(r.snapshotId, "snapshotId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restoreDbToRdsInstanceRequest == nil {
		return localVarReturnValue, nil, reportError("restoreDbToRdsInstanceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restoreDbToRdsInstanceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestoreDynamoDBTableRequest struct {
	ctx context.Context
	ApiService *SnapshotsAPIService
	projectId string
	id string
	snapshotId string
	restoreDynamoDBTableRequest *RestoreDynamoDBTableRequest
}

func (r ApiRestoreDynamoDBTableRequest) RestoreDynamoDBTableRequest(restoreDynamoDBTableRequest RestoreDynamoDBTableRequest) ApiRestoreDynamoDBTableRequest {
	r.restoreDynamoDBTableRequest = &restoreDynamoDBTableRequest
	return r
}

func (r ApiRestoreDynamoDBTableRequest) Execute() (*RestoreJobInitiationResponse, *http.Response, error) {
	return r.ApiService.RestoreDynamoDBTableExecute(r)
}

/*
RestoreDynamoDBTable Restore DynamoDB Table

Description: Restores a DynamoDB table from an Eon snapshot.

This operation is asynchronous.
It triggers a restore job and returns a job ID, which can be used to track the progress of the restore job.
You can follow the progress of the restore job by calling [Get Restore Job](/api/reference/get-restore-job) with the job ID.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId ID of the project the snapshot is in. You can get your project ID from the [API Credentials](/global-settings/api-credentials) page in your global settings. 
 @param id Eon-assigned resource ID.
 @param snapshotId ID of the Eon [snapshot](./list-resource-snapshots) to restore.
 @return ApiRestoreDynamoDBTableRequest
*/
func (a *SnapshotsAPIService) RestoreDynamoDBTable(ctx context.Context, projectId string, id string, snapshotId string) ApiRestoreDynamoDBTableRequest {
	return ApiRestoreDynamoDBTableRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		id: id,
		snapshotId: snapshotId,
	}
}

// Execute executes the request
//  @return RestoreJobInitiationResponse
func (a *SnapshotsAPIService) RestoreDynamoDBTableExecute(r ApiRestoreDynamoDBTableRequest) (*RestoreJobInitiationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestoreJobInitiationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SnapshotsAPIService.RestoreDynamoDBTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/resources/{id}/snapshots/{snapshotId}/restore-dynamo-db-table"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", url.PathEscape(parameterValueToString(r.snapshotId, "snapshotId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restoreDynamoDBTableRequest == nil {
		return localVarReturnValue, nil, reportError("restoreDynamoDBTableRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restoreDynamoDBTableRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestoreEbsVolumeRequest struct {
	ctx context.Context
	ApiService *SnapshotsAPIService
	projectId string
	id string
	snapshotId string
	restoreVolumeToEbsRequest *RestoreVolumeToEbsRequest
}

func (r ApiRestoreEbsVolumeRequest) RestoreVolumeToEbsRequest(restoreVolumeToEbsRequest RestoreVolumeToEbsRequest) ApiRestoreEbsVolumeRequest {
	r.restoreVolumeToEbsRequest = &restoreVolumeToEbsRequest
	return r
}

func (r ApiRestoreEbsVolumeRequest) Execute() (*RestoreJobInitiationResponse, *http.Response, error) {
	return r.ApiService.RestoreEbsVolumeExecute(r)
}

/*
RestoreEbsVolume Restore EBS Volume

Description: Restores an EBS volume from an Eon snapshot.

This operation is asynchronous.
It triggers a restore job and returns a job ID, which can be used to track the progress of the restore job.
You can follow the progress of the restore job by calling [Get Restore Job](/api/reference/get-restore-job) with the job ID.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId ID of the project the snapshot is in. You can get your project ID from the [API Credentials](/global-settings/api-credentials) page in your global settings. 
 @param id Eon-assigned resource ID.
 @param snapshotId ID of the Eon [snapshot](./list-resource-snapshots) to restore.
 @return ApiRestoreEbsVolumeRequest
*/
func (a *SnapshotsAPIService) RestoreEbsVolume(ctx context.Context, projectId string, id string, snapshotId string) ApiRestoreEbsVolumeRequest {
	return ApiRestoreEbsVolumeRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		id: id,
		snapshotId: snapshotId,
	}
}

// Execute executes the request
//  @return RestoreJobInitiationResponse
func (a *SnapshotsAPIService) RestoreEbsVolumeExecute(r ApiRestoreEbsVolumeRequest) (*RestoreJobInitiationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestoreJobInitiationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SnapshotsAPIService.RestoreEbsVolume")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/resources/{id}/snapshots/{snapshotId}/restore-ec2-ebs-volume"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", url.PathEscape(parameterValueToString(r.snapshotId, "snapshotId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restoreVolumeToEbsRequest == nil {
		return localVarReturnValue, nil, reportError("restoreVolumeToEbsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restoreVolumeToEbsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestoreEc2InstanceRequest struct {
	ctx context.Context
	ApiService *SnapshotsAPIService
	projectId string
	id string
	snapshotId string
	restoreAwsEc2InstanceRequest *RestoreAwsEc2InstanceRequest
}

func (r ApiRestoreEc2InstanceRequest) RestoreAwsEc2InstanceRequest(restoreAwsEc2InstanceRequest RestoreAwsEc2InstanceRequest) ApiRestoreEc2InstanceRequest {
	r.restoreAwsEc2InstanceRequest = &restoreAwsEc2InstanceRequest
	return r
}

func (r ApiRestoreEc2InstanceRequest) Execute() (*RestoreJobInitiationResponse, *http.Response, error) {
	return r.ApiService.RestoreEc2InstanceExecute(r)
}

/*
RestoreEc2Instance Restore EC2 Instance

Description: Restores an EC2 instance from an Eon snapshot.

When restoring an EC2 instance, you'll need to specify the configurations of the instance and each volume you want to restore.
You can retrieve the configurations from the snapshot by calling [Get Snapshot](/api/reference/get-snapshot) or [List Resource Snapshots](/api/reference/list-resource-snapshots).

This operation is asynchronous.
It triggers a restore job and returns a job ID, which can be used to track the progress of the restore job.
You can follow the progress of the restore job by calling [Get Restore Job](/api/reference/get-restore-job) with the job ID.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId ID of the project the snapshot is in. You can get your project ID from the [API Credentials](/global-settings/api-credentials) page in your global settings. 
 @param id Eon-assigned resource ID.
 @param snapshotId ID of the Eon [snapshot](./list-resource-snapshots) to restore.
 @return ApiRestoreEc2InstanceRequest
*/
func (a *SnapshotsAPIService) RestoreEc2Instance(ctx context.Context, projectId string, id string, snapshotId string) ApiRestoreEc2InstanceRequest {
	return ApiRestoreEc2InstanceRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		id: id,
		snapshotId: snapshotId,
	}
}

// Execute executes the request
//  @return RestoreJobInitiationResponse
func (a *SnapshotsAPIService) RestoreEc2InstanceExecute(r ApiRestoreEc2InstanceRequest) (*RestoreJobInitiationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestoreJobInitiationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SnapshotsAPIService.RestoreEc2Instance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/resources/{id}/snapshots/{snapshotId}/restore-ec2-instance"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", url.PathEscape(parameterValueToString(r.snapshotId, "snapshotId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restoreAwsEc2InstanceRequest == nil {
		return localVarReturnValue, nil, reportError("restoreAwsEc2InstanceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restoreAwsEc2InstanceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestoreFilesRequest struct {
	ctx context.Context
	ApiService *SnapshotsAPIService
	projectId string
	id string
	snapshotId string
	restoreFilesRequest *RestoreFilesRequest
}

func (r ApiRestoreFilesRequest) RestoreFilesRequest(restoreFilesRequest RestoreFilesRequest) ApiRestoreFilesRequest {
	r.restoreFilesRequest = &restoreFilesRequest
	return r
}

func (r ApiRestoreFilesRequest) Execute() (*RestoreJobInitiationResponse, *http.Response, error) {
	return r.ApiService.RestoreFilesExecute(r)
}

/*
RestoreFiles Restore Files

Description: Restores files from an Eon snapshot.

This operation is asynchronous.
It triggers a restore job and returns a job ID, which can be used to track the progress of the restore job.
You can follow the progress of the restore job by calling [Get Restore Job](/api/reference/get-restore-job) with the job ID.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId ID of the project the snapshot is in. You can get your project ID from the [API Credentials](/global-settings/api-credentials) page in your global settings. 
 @param id Eon-assigned resource ID.
 @param snapshotId ID of the Eon [snapshot](./list-resource-snapshots) to restore.
 @return ApiRestoreFilesRequest
*/
func (a *SnapshotsAPIService) RestoreFiles(ctx context.Context, projectId string, id string, snapshotId string) ApiRestoreFilesRequest {
	return ApiRestoreFilesRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		id: id,
		snapshotId: snapshotId,
	}
}

// Execute executes the request
//  @return RestoreJobInitiationResponse
func (a *SnapshotsAPIService) RestoreFilesExecute(r ApiRestoreFilesRequest) (*RestoreJobInitiationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestoreJobInitiationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SnapshotsAPIService.RestoreFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/resources/{id}/snapshots/{snapshotId}/restore-files"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", url.PathEscape(parameterValueToString(r.snapshotId, "snapshotId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restoreFilesRequest == nil {
		return localVarReturnValue, nil, reportError("restoreFilesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restoreFilesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestoreGcpCloudSqlRequest struct {
	ctx context.Context
	ApiService *SnapshotsAPIService
	projectId string
	id string
	snapshotId string
	restoreGcpCloudSqlRequest *RestoreGcpCloudSqlRequest
}

func (r ApiRestoreGcpCloudSqlRequest) RestoreGcpCloudSqlRequest(restoreGcpCloudSqlRequest RestoreGcpCloudSqlRequest) ApiRestoreGcpCloudSqlRequest {
	r.restoreGcpCloudSqlRequest = &restoreGcpCloudSqlRequest
	return r
}

func (r ApiRestoreGcpCloudSqlRequest) Execute() (*RestoreJobInitiationResponse, *http.Response, error) {
	return r.ApiService.RestoreGcpCloudSqlExecute(r)
}

/*
RestoreGcpCloudSql Restore GCP Cloud SQL Instance

Description: Restores a GCP Cloud SQL instance from an Eon snapshot.

When restoring a GCP Cloud SQL instance, you'll need to specify the configurations of the database instance you want to restore.
You can retrieve the configurations from the snapshot by calling [Get Snapshot](/api/reference/get-snapshot) or [List Resource Snapshots](/api/reference/list-resource-snapshots).

This operation is asynchronous.
It triggers a restore job and returns a job ID, which can be used to track the progress of the restore job.
You can follow the progress of the restore job by calling [Get Restore Job](/api/reference/get-restore-job) with the job ID.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId ID of the project the snapshot is in. You can get your project ID from the [API Credentials](/global-settings/api-credentials) page in your global settings. 
 @param id Eon-assigned resource ID.
 @param snapshotId ID of the Eon [snapshot](./list-resource-snapshots) to restore.
 @return ApiRestoreGcpCloudSqlRequest
*/
func (a *SnapshotsAPIService) RestoreGcpCloudSql(ctx context.Context, projectId string, id string, snapshotId string) ApiRestoreGcpCloudSqlRequest {
	return ApiRestoreGcpCloudSqlRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		id: id,
		snapshotId: snapshotId,
	}
}

// Execute executes the request
//  @return RestoreJobInitiationResponse
func (a *SnapshotsAPIService) RestoreGcpCloudSqlExecute(r ApiRestoreGcpCloudSqlRequest) (*RestoreJobInitiationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestoreJobInitiationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SnapshotsAPIService.RestoreGcpCloudSql")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/resources/{id}/snapshots/{snapshotId}/restore-gcp-cloudsql"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", url.PathEscape(parameterValueToString(r.snapshotId, "snapshotId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restoreGcpCloudSqlRequest == nil {
		return localVarReturnValue, nil, reportError("restoreGcpCloudSqlRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restoreGcpCloudSqlRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestoreGcpDiskRequest struct {
	ctx context.Context
	ApiService *SnapshotsAPIService
	projectId string
	id string
	snapshotId string
	restoreGcpDiskRequest *RestoreGcpDiskRequest
}

func (r ApiRestoreGcpDiskRequest) RestoreGcpDiskRequest(restoreGcpDiskRequest RestoreGcpDiskRequest) ApiRestoreGcpDiskRequest {
	r.restoreGcpDiskRequest = &restoreGcpDiskRequest
	return r
}

func (r ApiRestoreGcpDiskRequest) Execute() (*RestoreJobInitiationResponse, *http.Response, error) {
	return r.ApiService.RestoreGcpDiskExecute(r)
}

/*
RestoreGcpDisk Restore GCP Disk

Description: Restores a GCP disk from an Eon snapshot.

When restoring a disk, you'll specify the configurations of the disk you want to restore.
You can retrieve the configurations from the snapshot by calling [Get Snapshot](/api/reference/get-snapshot) or [List Resource Snapshots](/api/reference/list-resource-snapshots).

This operation is asynchronous.
It triggers a restore job and returns a job ID, which can be used to track the progress of the restore job.
You can follow the progress of the restore job by calling [Get Restore Job](/api/reference/get-restore-job) with the job ID.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId ID of the project the snapshot is in. You can get your project ID from the [API Credentials](/global-settings/api-credentials) page in your global settings. 
 @param id Eon-assigned resource ID.
 @param snapshotId ID of the Eon [snapshot](./list-resource-snapshots) to restore.
 @return ApiRestoreGcpDiskRequest
*/
func (a *SnapshotsAPIService) RestoreGcpDisk(ctx context.Context, projectId string, id string, snapshotId string) ApiRestoreGcpDiskRequest {
	return ApiRestoreGcpDiskRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		id: id,
		snapshotId: snapshotId,
	}
}

// Execute executes the request
//  @return RestoreJobInitiationResponse
func (a *SnapshotsAPIService) RestoreGcpDiskExecute(r ApiRestoreGcpDiskRequest) (*RestoreJobInitiationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestoreJobInitiationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SnapshotsAPIService.RestoreGcpDisk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/resources/{id}/snapshots/{snapshotId}/restore-gcp-disk"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", url.PathEscape(parameterValueToString(r.snapshotId, "snapshotId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restoreGcpDiskRequest == nil {
		return localVarReturnValue, nil, reportError("restoreGcpDiskRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restoreGcpDiskRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestoreGcpVmInstanceRequest struct {
	ctx context.Context
	ApiService *SnapshotsAPIService
	projectId string
	id string
	snapshotId string
	restoreGcpVmInstanceRequest *RestoreGcpVmInstanceRequest
}

func (r ApiRestoreGcpVmInstanceRequest) RestoreGcpVmInstanceRequest(restoreGcpVmInstanceRequest RestoreGcpVmInstanceRequest) ApiRestoreGcpVmInstanceRequest {
	r.restoreGcpVmInstanceRequest = &restoreGcpVmInstanceRequest
	return r
}

func (r ApiRestoreGcpVmInstanceRequest) Execute() (*RestoreJobInitiationResponse, *http.Response, error) {
	return r.ApiService.RestoreGcpVmInstanceExecute(r)
}

/*
RestoreGcpVmInstance Restore GCP VM Instance

Description: Restores a GCP VM instance from an Eon snapshot.

When restoring a GCP VM instance, you'll need to specify the configurations of the instance and each disk you want to restore.
You can retrieve the configurations from the snapshot by calling [Get Snapshot](/api/reference/get-snapshot) or [List Resource Snapshots](/api/reference/list-resource-snapshots).

This operation is asynchronous.
It triggers a restore job and returns a job ID, which can be used to track the progress of the restore job.
You can follow the progress of the restore job by calling [Get Restore Job](/api/reference/get-restore-job) with the job ID.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId ID of the project the snapshot is in. You can get your project ID from the [API Credentials](/global-settings/api-credentials) page in your global settings. 
 @param id Eon-assigned resource ID.
 @param snapshotId ID of the Eon [snapshot](./list-resource-snapshots) to restore.
 @return ApiRestoreGcpVmInstanceRequest
*/
func (a *SnapshotsAPIService) RestoreGcpVmInstance(ctx context.Context, projectId string, id string, snapshotId string) ApiRestoreGcpVmInstanceRequest {
	return ApiRestoreGcpVmInstanceRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		id: id,
		snapshotId: snapshotId,
	}
}

// Execute executes the request
//  @return RestoreJobInitiationResponse
func (a *SnapshotsAPIService) RestoreGcpVmInstanceExecute(r ApiRestoreGcpVmInstanceRequest) (*RestoreJobInitiationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestoreJobInitiationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SnapshotsAPIService.RestoreGcpVmInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/resources/{id}/snapshots/{snapshotId}/restore-gcp-vm-instance"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", url.PathEscape(parameterValueToString(r.snapshotId, "snapshotId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restoreGcpVmInstanceRequest == nil {
		return localVarReturnValue, nil, reportError("restoreGcpVmInstanceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restoreGcpVmInstanceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestoreToEbsSnapshotRequest struct {
	ctx context.Context
	ApiService *SnapshotsAPIService
	projectId string
	id string
	snapshotId string
	restoreVolumeToEbsSnapshotRequest *RestoreVolumeToEbsSnapshotRequest
}

func (r ApiRestoreToEbsSnapshotRequest) RestoreVolumeToEbsSnapshotRequest(restoreVolumeToEbsSnapshotRequest RestoreVolumeToEbsSnapshotRequest) ApiRestoreToEbsSnapshotRequest {
	r.restoreVolumeToEbsSnapshotRequest = &restoreVolumeToEbsSnapshotRequest
	return r
}

func (r ApiRestoreToEbsSnapshotRequest) Execute() (*RestoreJobInitiationResponse, *http.Response, error) {
	return r.ApiService.RestoreToEbsSnapshotExecute(r)
}

/*
RestoreToEbsSnapshot Restore to EBS Snapshot

Description: Restores an Eon volume snapshot to an EBS snapshot.

This operation is asynchronous.
It triggers a restore job and returns a job ID, which can be used to track the progress of the restore job.
You can follow the progress of the restore job by calling [Get Restore Job](/api/reference/get-restore-job) with the job ID.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId ID of the project the snapshot is in. You can get your project ID from the [API Credentials](/global-settings/api-credentials) page in your global settings. 
 @param id Eon-assigned resource ID.
 @param snapshotId ID of the Eon [snapshot](./list-resource-snapshots) to restore.
 @return ApiRestoreToEbsSnapshotRequest
*/
func (a *SnapshotsAPIService) RestoreToEbsSnapshot(ctx context.Context, projectId string, id string, snapshotId string) ApiRestoreToEbsSnapshotRequest {
	return ApiRestoreToEbsSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		id: id,
		snapshotId: snapshotId,
	}
}

// Execute executes the request
//  @return RestoreJobInitiationResponse
func (a *SnapshotsAPIService) RestoreToEbsSnapshotExecute(r ApiRestoreToEbsSnapshotRequest) (*RestoreJobInitiationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestoreJobInitiationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SnapshotsAPIService.RestoreToEbsSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/resources/{id}/snapshots/{snapshotId}/convert-ec2-ebs-snapshot"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", url.PathEscape(parameterValueToString(r.snapshotId, "snapshotId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restoreVolumeToEbsSnapshotRequest == nil {
		return localVarReturnValue, nil, reportError("restoreVolumeToEbsSnapshotRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restoreVolumeToEbsSnapshotRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
